# DataStructure-数据结构
数据结构实现
##1、BST java实现

###数据结构
```java
class BiTreeNode{
    public int key;
    public BiTreeNode lchild;//左子树
    public BiTreeNode rchild;//右子树
    public BiTreeNode parent;//父结点
}
```
###查找过程

在二叉搜索树b中查找x的过程为：
>若b是空树，则搜索失败，否则：

>若x等于b的根节点的数据域之值，则查找成功；否则：

>若x小于b的根节点的数据域之值，则搜索左子树；否则：

>查找右子树。

查找结果成功返回该结点，失败返回失败结点的父节点，主要用于其他操作做准备

###添加过程

>查找若成功则代表存在，不允许插入

>若s->data等于b的根节点的数据域之值，则返回，否则：

>若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：

>把s所指节点插入到右子树中。（新插入节点总是叶子节点）

###删除过程
删除分为4种情况、叶子结点不存在、只有左叶子结点、只有右叶子结点、左右叶子结点都存在

>查找到待删除的结点

>若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。

>若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）或右子树（当*p是右子树）即可，作此修改也不破坏二叉查找树的特性。

>若*p结点的左子树和右子树均不空。在删去*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令*p的左子树为*f的左/右（依*p是*f的左子树还是右子树而定）子树，*s为*p左子树的最右下的结点，而*p的右子树为*s的右子树；其二是令*p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代*p，然后再从二叉查找树中删去它的直接前驱（或直接后继）

